<html>
<head>
  <title>Machine Learning Visualization </title>
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
  <link rel="stylesheet" href="../css/hljs-base16.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <meta charset="utf-8">
  <style>
    .canvas_pos {
        
        width: 224px;
        height: 224px;
    }

    #heatmap_ {
        margin-right:100px;
        margin-left:-226px;
    }

    #segments_ {
        margin-left:200px;
        margin-top:-284px;
    }


    #model_2 {
       margin-left:200px;
    }

    #main_image {
        margin-left:300px;
        
    }

    #visualization {
        float: left;
        margin-right: 100px;
    }

    #visualization expl_image{
        margin-top: 300px;
    }

    #segment_vis {
        margin-left:300px;
        float: center;
    }

    #segment_vis div{
        height: 50px;
        width:280px;
        
        display: flex;
        align-items: center;
    }

  </style>
</head>
    
<body>
  <div class="container larger">
  <h4>April 25 Notes</h4>
  <p> In this lecture, we will explore how visualizations can be used
      beyond data exploration tasks, to understand something as complex as
      Machine Learning decision making. </p>
  <p> A machine learnign model derives the relationship between input 
        and output using the computational units of its architecture.
  </p>
        <img src="../datasets/ml_model_1.jpg" width="300" height="200" > 

        <img src="../datasets/ml_model_2.jpg" width="300" height="200" id="model_2">
    
    <p> Consider the below example, where an image is input into Resnet50, a popular
        image classification model and our task is to understand what led to the given decision. </p>

    <label for="main_image" id="main_image"> My dog Gabru ready for a walk in snow.</label>
    <img src="../datasets/ml_image_1.jpg" width="500" height="650" id="main_image">
    &nbsp;
    &nbsp;
    &nbsp;
    <p> <br>The above image was classified as <b>Broom</b> (0.59% probability), 
        <b>Honeycomb</b> (0.54% probability), <b>Plunger</b> (0.52% probability), 
        <b>Tennis Ball</b> (0.51% probability)  or <b>Panpipe</b> (0.46% probability).
     </p>

    <h5>HTML for today:</h5>

    <p> Visualizationthe decisions: Heatmap is one popular 
        technique to explore the important features. </p>
    <div id="visualization">
        <label for="expl_image" > Importance weights generated by the explanation algorithm</label>
        <img src="../datasets/ml_image_1_resized.png" class="canvas_pos" id="expl_image"></img>
 
    </div>

    <div id="segment_vis">
        
        <label for="expl_image" > Dividing image into meaningful segments</label>
        <img src="../datasets/ml_image_1_resized.png" class="canvas_pos" id="seg_image">
        <div id="sliderControl" >
            <input type="range" id="segments" 
                    name="segments" min="25" max="225" value="25" step="25">
            <label for="segments"> Segments Created: <span id="segmentValue">0</span></label>
        </div>
 
    </div>
    
    <div>
        <h5>Code for today:</h5>
        <pre>
        <code id="display1" class="hljs javascript">
        </code>
        </pre>
    </div>
   
</div>

  <script id="notes1">

        function heatmap(in_data){

            //organize the canvas a bit
            let width = in_data[0].length;
            let height = in_data.length;

            //convert data to 1-D array for simplicity for binding
            in_data_1D=[]
            in_data.forEach((el,i)=>{
                el.forEach( (val,j)=>{
                    in_data_1D.push({'x':j,
                                     'y':i%width,
                                     'value':val})})
                })

            //
            calc_1D= in_data.flat()
            let min = d3.min(calc_1D)
            let max = d3.max(calc_1D)

            //make the colorscale for explanation heat map
            var heatmap_color = d3.scaleSequential()
                                  .interpolator(d3.interpolateViridis)
                                  .domain([min,max])

            var canvas = d3.select('#visualization')
                        .append('canvas')
                        .attr('width', width)
                        .attr('height', height)
                        .attr("class","canvas_pos")
                        .attr("id","heatmap_");

            var context = canvas.node().getContext('2d');

            // create a parent for all the elements
            var explanation = document.createElement('explanation');
            var heatmap = d3.select(explanation);

            //bind the data to canvas elements
            heatmap.selectAll('explanation.rect')
                    .data(in_data_1D)
                    .enter()
                    .append('explanation')
                    .attr('class','rect')
                    .attr("height","1")
                    .attr("width","1")
                    .attr("x",(el)=>{return el.x })
                    .attr("y",(el)=>{return el.y })
                    //.attr("fill","color")
                    .attr("fillStyle",(el)=>{
                        var color_ = d3.color(heatmap_color(el.value))
                        color_.opacity = 0.5;
                        return color_+ ""
                    
                    })

            //console.log(d3.color(heatmap_color(0.5)))

            //clean the canvas
            context.clearRect(0, 0, width, height);

            //now draw elements
            heatmap.selectAll('explanation.rect')
                        .each(function(d,i){
                        var node = d3.select(this);
                            context.beginPath();
                            context.rect(node.attr('x'), 
                                         node.attr('y'), 
                                         node.attr('width'),
                                         node.attr('height'));
                            context.fillStyle = node.attr('fillStyle');
                            context.fill();
                         })
        }

        function segment_map(in_data){

            let segment_number = 25
            seg_data = in_data['segments_'+segment_number]

            //organize the canvas a bit
            let width = seg_data[0].length;
            let height = seg_data.length;

            //convert data to 1-D array for simplicity for binding
            in_data_1D=[]
            counter=1
            seg_data.forEach((el,i)=>{
                el.forEach( (val,j)=>{
                    in_data_1D.push({'id':"id_"+counter,
                                    'x':j,
                                    'y':i%width,
                                    'value':val})
                    counter+=1       
                                    })
                })

            //alternateively you could flatten it and compute the x and y during binding process
            //in_data_1D = seg_data.flat()

            //make colorscale for segments
            /*var segment_colorscale = d3.scaleOrdinal(d3.schemeCategory10)
                                        .domain([0,segment_number])*/

            var segment_colorscale = d3.scaleSequential()
                                .interpolator(d3.interpolateViridis)
                                .domain([0,1])

            // create convas and get context
            var canvas = d3.select('#segment_vis') 
                        .append('canvas')
                        .attr('width', width)
                        .attr('height', height)
                        .attr("class","canvas_pos")
                        .attr("id","segments_");

            var context = canvas.node().getContext('2d');

            // create a parent for all the elements
            var explanation = document.createElement('explanation');
            var heatmap = d3.select(explanation);

            function update_segments(segment_data){

                var dataJoin =  heatmap.selectAll('explanation.rect')
                            .data(segment_data,d=>d.id)
                            .join(
                                enter=>enter.append('explanation')
                                        .attr('class','rect')
                                        .attr("height","1")
                                        .attr("width","1")
                                        .attr("x",(el)=>{return el.x })
                                        .attr("y",(el)=>{return el.y })
                                        .attr("fillStyle",(el)=>{
                                            var color_ = d3.color(segment_colorscale(el.value))
                                            color_.opacity = 0.5;
                                            return color_+ ""}),
                                update=>update.call(update=>update.transition()
                                        .duration(1)
                                        .attr("fillStyle",(el)=>{
                                            var color_ = d3.color(segment_colorscale(el.value))
                                            color_.opacity = 0.5;
                                            return color_+ ""
                                            })),
                                exit=>exit.remove())
                

                //clean the canvas
                context.clearRect(0, 0, width, height);

                //now draw elements
                heatmap.selectAll('explanation.rect')
                            .each(function(d,i){
                            var node = d3.select(this);
                                context.beginPath();
                                context.rect(node.attr('x'), 
                                            node.attr('y'), 
                                            node.attr('width'),
                                            node.attr('height'));
                                context.fillStyle = node.attr('fillStyle');
                                context.fill();
                            })

            }

            d3.select("#segments").on("input",function(){

                let segment_number = this.value

                d3.select("#segmentValue").text(segment_number)

                //get average of regions
                merged_data = merge_algorithm(in_data,segment_number)
                update_segments(merged_data)

            })
    
        }

    function merge_algorithm(in_data,segment_num){

        //isolate all regions
        var mean = {}

        exp_data = in_data['explanations']
        seg_data = in_data['segments_'+segment_num]

        let width = exp_data[0].length

        seg_data.forEach((el,i)=>{
                    el.forEach((val,j)=>{
                        if(!(val in mean)){
                            mean[val]=[]
                        }
                        mean[val].push(exp_data[i][j])
                        
                    })
        })

        //calculate mean
        var calc_mean={}
        for (const [key, value] of Object.entries(mean)) {
            sum_ = value.reduce((a, b) => a + b)
            calc_mean[key] = sum_/value.length;
        }


        // dump result in final output
        outdata=[]
        counter=1
        exp_data.forEach((el,i)=>{
                el.forEach( (val,j)=>{
                    outdata.push({'id':"id_"+counter,
                                    'x':j,
                                    'y':i%width,
                                    'value':calc_mean[seg_data[i][j]]})
                    counter+=1            
                    })
        })

        return outdata

        }
        d3.json("../datasets/ml_data.json").then(function(data){

            //see the data
            console.log(data['explanations'])
            // get the machine heatmap
            var explanation = data['explanations']

            //draw the heat map for the explanation
            heatmap(explanation)

            //get the segment data
            segment_map(data)

            //merge data
            //merge_algorithm(data,25)


        })
  </script>
   <!--- calls the highlight library to fill the <pre> tag with code --->
    <script>
    
        function sanitize(s) {
          return s.replace("<br>", "\\n")
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#039;");
                }
          document.getElementById("display1").innerHTML = sanitize( document.getElementById("notes1").innerText);
          hljs.highlightAll();
        </script> 
</body>
</html>
